import React, { useState, useEffect, useRef } from "react";
import { logsAPI } from "../services/api";
import "./LogsPage.css";

const LogsPage = () => {
  const [logs, setLogs] = useState([]);
  const [status, setStatus] = useState(null);
  const [loading, setLoading] = useState(false);
  const [autoRefresh, setAutoRefresh] = useState(false);
  const [logType, setLogType] = useState("all");
  const [numLines, setNumLines] = useState(100);
  const [searchTerm, setSearchTerm] = useState("");
  const [copiedLine, setCopiedLine] = useState(null);
  const intervalRef = useRef(null);
  const logContainerRef = useRef(null);

  useEffect(() => {
    fetchLogs();
    fetchStatus();
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [logType, numLines]);

  useEffect(() => {
    if (autoRefresh) {
      intervalRef.current = setInterval(() => {
        fetchLogs();
        fetchStatus();
      }, 3000);
    } else {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    }
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [autoRefresh, logType, numLines]);

  const fetchLogs = async () => {
    setLoading(true);
    try {
      const response = await logsAPI.getBackend(numLines, logType);
      setLogs(response.data.logs);
    } catch (error) {
      console.error("Failed to fetch logs:", error);
    } finally {
      setLoading(false);
    }
  };

  const fetchStatus = async () => {
    try {
      const response = await logsAPI.getStatus();
      setStatus(response.data);
    } catch (error) {
      console.error("Failed to fetch status:", error);
    }
  };

  const handleRestart = async () => {
    if (!window.confirm("Are you sure you want to restart the backend?")) return;
    
    try {
      await logsAPI.restartBackend();
      alert("Backend restarted successfully");
      fetchStatus();
      fetchLogs();
    } catch (error) {
      alert("Failed to restart backend: " + error.message);
    }
  };

  const handleFlush = async () => {
    if (!window.confirm("Are you sure you want to flush all logs?")) return;
    
    try {
      await logsAPI.flushBackend();
      alert("Logs flushed successfully");
      fetchLogs();
    } catch (error) {
      alert("Failed to flush logs: " + error.message);
    }
  };

  const handleCopyLine = (log) => {
    navigator.clipboard.writeText(log.raw).then(() => {
      setCopiedLine(log.id);
      setTimeout(() => setCopiedLine(null), 2000);
    });
  };

  const handleCopyAll = () => {
    const allLogs = logs.map(log => log.raw).join("\n");
    navigator.clipboard.writeText(allLogs).then(() => {
      alert("All logs copied to clipboard!");
    });
  };

  const filteredLogs = logs.filter(log =>
    log.raw.toLowerCase().includes(searchTerm.toLowerCase()) ||
    (log.message && log.message.toLowerCase().includes(searchTerm.toLowerCase()))
  );

  const formatMemory = (bytes) => {
    if (!bytes) return "N/A";
    return (bytes / 1024 / 1024).toFixed(2) + " MB";
  };

  const formatUptime = (ms) => {
    if (!ms) return "N/A";
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ${hours % 24}h ${minutes % 60}m`;
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
  };

  return (
    <div className="logs-page">
      <div className="logs-header">
        <h1>Backend Logs Viewer</h1>
        
        {status && (
          <div className="status-panel">
            <div className={`status-indicator ${status.status}`}>
              <span className="status-dot"></span>
              <span className="status-text">{status.status.toUpperCase()}</span>
            </div>
            <div className="status-info">
              <span>PID: {status.pid}</span>
              <span>Memory: {formatMemory(status.memory)}</span>
              <span>Uptime: {formatUptime(status.uptime)}</span>
              <span>Restarts: {status.restarts}</span>
            </div>
          </div>
        )}
      </div>

      <div className="logs-controls">
        <div className="control-group">
          <label>Log Type:</label>
          <select value={logType} onChange={(e) => setLogType(e.target.value)}>
            <option value="all">All Logs</option>
            <option value="out">Output Only</option>
            <option value="error">Errors Only</option>
          </select>
        </div>

        <div className="control-group">
          <label>Lines:</label>
          <select value={numLines} onChange={(e) => setNumLines(parseInt(e.target.value))}>
            <option value="50">Last 50</option>
            <option value="100">Last 100</option>
            <option value="200">Last 200</option>
            <option value="500">Last 500</option>
          </select>
        </div>

        <div className="control-group">
          <label>
            <input
              type="checkbox"
              checked={autoRefresh}
              onChange={(e) => setAutoRefresh(e.target.checked)}
            />
            Auto Refresh (3s)
          </label>
        </div>

        <div className="control-group search-group">
          <input
            type="text"
            placeholder="Search logs..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="search-input"
          />
        </div>

        <button onClick={fetchLogs} disabled={loading} className="btn-refresh">
          {loading ? "Refreshing..." : "Refresh"}
        </button>

        <button onClick={handleCopyAll} className="btn-copy">
          Copy All
        </button>

        <button onClick={handleFlush} className="btn-flush">
          Flush Logs
        </button>

        <button onClick={handleRestart} className="btn-restart">
          Restart Backend
        </button>
      </div>

      <div className="logs-stats">
        <span>Showing {filteredLogs.length} of {logs.length} lines</span>
        {searchTerm && <span> (filtered: "{searchTerm}")</span>}
      </div>

      <div className="logs-container" ref={logContainerRef}>
        {filteredLogs.length === 0 ? (
          <div className="no-logs">
            {loading ? "Loading logs..." : searchTerm ? "No logs match your search" : "No logs available"}
          </div>
        ) : (
          <div className="logs-list">
            {filteredLogs.map((log) => (
              <div
                key={log.id}
                className={`log-line ${log.process?.includes("error") ? "error" : ""} ${log.process?.includes("sales-cr") ? "backend" : ""}`}
                onClick={() => handleCopyLine(log)}
                title="Click to copy"
              >
                <span className="log-meta">
                  {log.pid && <span className="log-pid">[{log.pid}]</span>}
                  {log.process && <span className="log-process">{log.process}</span>}
                </span>
                <span className="log-message">{log.message || log.raw}</span>
                {copiedLine === log.id && <span className="copied-badge">Copied!</span>}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default LogsPage;
